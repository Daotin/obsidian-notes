初衷

然后从项目运行性能和稳定性的角度来看，我们可以制定项目的性能指标，开发项目的性能监控系统，来实时监控客户端的性能，当页面有严重的性能问题或者报错的时候，能够及时通知我们。并且除了常见的性能优化策略之外，我们还可以分析用户访问日志，提前预测用户可能访问的页面，从而做路由级别的预加载等等。

[https://gitee.com/clark-fl/log.js?utm_source=gold_browser_extension](https://gitee.com/clark-fl/log.js?utm_source=gold_browser_extension)

[https://cn.vuejs.org/api/application.html#app-config-warnhandler](https://cn.vuejs.org/api/application.html#app-config-warnhandler)

[https://juejin.cn/post/6954303116783124487](https://juejin.cn/post/6954303116783124487)

[https://juejin.cn/post/6844903806849777677](https://juejin.cn/post/6844903806849777677)

[https://mp.weixin.qq.com/s/7c0yqwSxK-FvLm1iKZrjmQ](https://mp.weixin.qq.com/s/7c0yqwSxK-FvLm1iKZrjmQ)

对工程低入侵的错误采集方案

这个监控很简单，就是用了window.onerror 监听错误然后AJAX发送给后台。

vue

```
app.config.errorHandler

```

异常上报 1、Ajax 发送数据

2、动态创建 img 标签

如果异常数据量大，导致服务器负载高，调整发送频率（可以考虑把异常信息存储在客户端，设定时间阀值，进行上报）或设置采集率（采集率应该通过实际情况来设定，随机数，或者某些用户特征都是不错的选择）。

```js
/**
 *
 * 错误采集
 */

// window.onerror = (message, source, lineno, colno, error) => {
//   console.log('报错信息==>', message)
//   console.log('错误文件地址==>', source)
//   console.log('错误文件行数==>', lineno)
//   console.log('错误文件列数==>', colno)
//   console.log('错误Eoor对象堆栈==>', error)

//   return false; // 为true，则控制台不会打印错误信息
// }

window.addEventListener('error', (e) => {
  // e.preventDefault() // 则控制台不会打印错误信息
  console.log('==>', Object.prototype.toString.call(e))
  if (e instanceof ErrorEvent) {
    const { message, source, lineno, colno, error } = e;
    console.log('报错信息==>', message)
    console.log('错误文件地址==>', source)
    console.log('错误文件行数==>', lineno)
    console.log('错误文件列数==>', colno)
    console.log('错误Eoor对象堆栈==>', error)
  } else if(e instanceof Event){
    const { target } = e;
    console.log('资源错误==>', target.nodeName, target.src)
  }
}, true)

window.addEventListener('unhandledrejection', (e) => {
  e.preventDefault() // 则控制台不会打印错误信息

  if (e instanceof PromiseRejectionEvent) {
    console.log('==>', Object.prototype.toString.call(e.reason))
    console.log('异步错误信息==>', e.reason.message)
    // console.log('异步错误堆栈==>', e.reason.stack)

    const { filename, lineno, colno } = parseStack(e.reason.stack)

    console.log('异步错误文件地址==>', filename)
    console.log('异步错误文件行数==>', lineno)
    console.log('异步错误文件列数==>', colno)
  }
}, true)

function parseStack(stack) {
  const res = stack.split('\\n')
  const topFile = res[1].trim().split(' ')[1].trim();
  const files = topFile.split(/\\?/)
  const [, lineno, colno] = files[1].split(':')

  return {filename:files[0], lineno, colno}
}

// 劫持console.error采集错误信息
const _consoleError = window.console.error;

window.console.error = (...args) => {
  console.log('自定义内容')
  _consoleError.apply(window.error, args)
}

// 示例代码
function throwError() {
  throw new Error('出错了')
}

// throwError()

new Promise((resolve, reject) => {
  xxx
})

// new Promise((resolve, reject) => {
//   try {
//     xxx
//   } catch (error) {
//     console.error('xxx是啥')
//   }
// })

/**
 * 错误处理
 */

/** 错误类型 */
enum ErrorType {
  Error = 'error', // 普通 js 错误
  Resource = 'resource', // 资源加载错误
  Promise = 'promise', // 异步错误
}

/** 资源错误 */
type ResourceErrorDetailInfo = {
  type: ErrorType.Resource; // 错误类型
  tag: string; // 加载出错的资源标签，例如 img、script、link 等
  resourceUrl: string; // 资源地址
}

/** js 逻辑错误（包括同步错误、异步错误） */
type JsErrorDetailInfo = {
  type: ErrorType.Error | ErrorType.Promise;
  msg: string; // 错误信息
  resourceUrl: string; // 资源文件地址
  lineNo: number; // 错误行数
  colno: number; // 错误列数
  stack: string; // 错误堆栈
}

```

- [https://www.cnblogs.com/luozhihao/p/8635507.html](https://www.cnblogs.com/luozhihao/p/8635507.html)
    - [https://github.com/luozhihao/error-catch-report](https://github.com/luozhihao/error-catch-report)
- [http://jartto.wang/2018/11/20/js-exception-handling/index.html](http://jartto.wang/2018/11/20/js-exception-handling/index.html)
- [https://juejin.cn/post/6967152411542552607#heading-40](https://juejin.cn/post/6967152411542552607#heading-40)