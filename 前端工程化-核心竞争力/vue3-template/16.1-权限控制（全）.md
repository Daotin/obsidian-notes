# 前端权限设计方案

## 目录

- [1. 概述](#1-概述)
- [2. 用户-角色-权限模型](#2-用户-角色-权限模型)
- [3. 权限控制的层次](#3-权限控制的层次)
- [4. 方案一：动态路由方案](#4-方案一动态路由方案)
  - [4.1 实现原理](#41-实现原理)
  - [4.2 实现步骤](#42-实现步骤)
  - [4.3 核心代码实现](#43-核心代码实现)
  - [4.4 优缺点分析](#44-优缺点分析)
- [5. 方案二：静态路由+权限过滤方案](#5-方案二静态路由权限过滤方案)
  - [5.1 实现原理](#51-实现原理)
  - [5.2 实现思路](#52-实现思路)
  - [5.3 伪代码示例](#53-伪代码示例)
  - [5.4 优缺点分析](#54-优缺点分析)
- [6. 按钮权限控制实现](#6-按钮权限控制实现)
  - [6.1 自定义指令方式](#61-自定义指令方式)
  - [6.2 组件封装方式](#62-组件封装方式)
  - [6.3 工具函数方式](#63-工具函数方式)
- [7. 完整权限流程](#7-完整权限流程)
- [8. 方案选型建议](#8-方案选型建议)
- [9. 最佳实践与注意事项](#9-最佳实践与注意事项)

## 1. 概述

本文档详细描述了基于Vue3+Vite的前端权限控制设计方案，适用于中大型后台管理系统。权限控制是后台管理系统的核心功能，合理的权限设计可以满足不同用户对系统功能的差异化访问需求，提高系统安全性和可用性。

本方案基于RBAC权限模型，实现了包括路由权限、视图权限、操作权限和数据权限在内的多层次权限控制体系。

## 2. 用户-角色-权限模型

本方案采用基于角色的访问控制（RBAC）模型：

- **用户(User)**：系统的使用者，一个用户可以拥有多个角色
- **角色(Role)**：权限的集合，一个角色可以包含多个权限
- **权限(Permission)**：对特定资源的操作许可，如查看用户列表、新增用户等

核心关系：
- 一个用户可以对应多个角色
- 一个角色可以对应多个权限
- 用户的最终权限是其所有角色权限的并集

## 3. 权限控制的层次

现代前端权限控制通常分为以下几个层次：

### 3.1 路由权限

控制用户可以访问哪些页面/路由。在Vue Router中通过动态路由或路由守卫实现。

### 3.2 视图权限

控制页面上某些组件或区域是否对用户可见。

### 3.3 操作权限

控制用户是否能执行某些操作，如按钮点击、表单提交等。

### 3.4 数据权限

控制用户可以查看和操作哪些范围的数据，通常在后端实现，前端配合展示。

## 4. 方案一：动态路由方案

### 4.1 实现原理

动态路由方案的核心思想是：**路由配置完全来自后端**。

流程：
1. 用户登录后，前端向后端请求获取用户菜单数据
2. 前端将菜单数据转换为路由配置
3. 动态添加路由到Vue Router
4. 从菜单中提取按钮权限标识，用于控制按钮显示

### 4.2 实现步骤

1. 创建基础路由（登录、404等无需权限的路由）
2. 实现路由守卫，在用户登录后获取菜单数据
3. 将菜单数据转换为路由配置
4. 动态添加路由
5. 提取并存储按钮权限标识

### 4.3 核心代码实现

**路由基础配置：**

```javascript:src/router/index.js
import { createRouter, createWebHistory } from 'vue-router'

// 布局组件
import Layout from '@/layout/index.vue'

// 基础路由 - 所有用户都可访问
export const constantRoutes = [
  {
    path: '/login',
    component: () => import('@/views/login/index.vue'),
    hidden: true
  },
  {
    path: '/404',
    component: () => import('@/views/error/404.vue'),
    hidden: true
  },
  {
    path: '/',
    component: Layout,
    redirect: '/dashboard',
    children: [
      {
        path: 'dashboard',
        component: () => import('@/views/dashboard/index.vue'),
        name: 'Dashboard',
        meta: { title: '首页', icon: 'dashboard', affix: true }
      }
    ]
  }
]

// 创建路由实例
const router = createRouter({
  history: createWebHistory(),
  routes: constantRoutes,
  scrollBehavior: () => ({ top: 0 })
})

// 重置路由方法（用于退出登录时清空动态路由）
export function resetRouter() {
  const newRouter = createRouter({
    history: createWebHistory(),
    routes: constantRoutes,
    scrollBehavior: () => ({ top: 0 })
  })
  router.matcher = newRouter.matcher
}

export default router
```

**权限状态管理（使用Pinia）：**

```javascript:src/stores/permission.js
import { defineStore } from 'pinia'
import { constantRoutes } from '@/router'
import { getMenuList } from '@/api/menu'

/**
 * 动态加载组件
 * @param {string} component 组件路径
 * @returns {Function} 组件加载函数
 */
function loadComponent(component) {
  // 布局组件特殊处理
  if (component === 'Layout') {
    return () => import('@/layout/index.vue')
  }
  // 处理路径前缀
  if (component.startsWith('/')) {
    component = component.slice(1)
  }
  // 动态导入组件
  return () => import(`@/views/${component}.vue`)
}

export const usePermissionStore = defineStore('permission', {
  state: () => ({
    // 路由列表
    routes: [],
    // 按钮权限列表
    permissions: []
  }),

  actions: {
    /**
     * 生成路由
     */
    async generateRoutes() {
      try {
        // 获取菜单数据
        const { data } = await getMenuList()
        
        // 提取所有按钮权限
        const permissions = []
        const extractPermissions = (menus) => {
          menus.forEach(menu => {
            if (menu.perms && Array.isArray(menu.perms)) {
              permissions.push(...menu.perms)
            }
            if (menu.children && menu.children.length) {
              extractPermissions(menu.children)
            }
          })
        }
        extractPermissions(data)
        
        // 存储按钮权限
        this.permissions = permissions
        
        // 生成路由配置
        const asyncRoutes = this.generateRoutesFromMenus(data)
        
        // 合并基础路由和动态路由
        const accessRoutes = [...asyncRoutes]
        this.routes = [...constantRoutes, ...accessRoutes]
        
        return accessRoutes
      } catch (error) {
        console.error('获取菜单失败', error)
        return []
      }
    },
    
    /**
     * 将菜单数据转换为路由配置
     * @param {Array} menus 菜单数据
     * @returns {Array} 路由配置
     */
    generateRoutesFromMenus(menus) {
      const routes = []
      
      menus.forEach(menu => {
        // 构建路由对象
        const route = {
          path: menu.path,
          name: menu.name,
          component: loadComponent(menu.component),
          meta: {
            title: menu.title,
            icon: menu.icon,
            hidden: menu.hidden,
            keepAlive: menu.keepAlive
          }
        }
        
        // 处理重定向
        if (menu.redirect) {
          route.redirect = menu.redirect
        }
        
        // 处理子路由
        if (menu.children && menu.children.length) {
          route.children = this.generateRoutesFromMenus(menu.children)
        }
        
        routes.push(route)
      })
      
      return routes
    },
    
    /**
     * 检查是否有权限
     * @param {string|string[]} permission 权限标识
     * @returns {boolean} 是否有权限
     */
    hasPermission(permission) {
      if (!permission) {
        return true
      }
      
      const permissions = this.permissions
      
      if (typeof permission === 'string') {
        return permissions.includes(permission)
      }
      
      if (Array.isArray(permission)) {
        return permission.some(p => permissions.includes(p))
      }
      
      return false
    }
  }
})
```

**路由守卫实现：**

```javascript:src/permission.js
import router from './router'
import { useUserStore } from '@/stores/user'
import { usePermissionStore } from '@/stores/permission'
import NProgress from 'nprogress'
import 'nprogress/nprogress.css'
import { getToken } from '@/utils/auth'

// 白名单（不需要登录就可以访问的路由）
const whiteList = ['/login', '/auth-redirect', '/404']

// 进度条配置
NProgress.configure({ showSpinner: false })

// 全局前置守卫
router.beforeEach(async (to, from, next) => {
  // 开始进度条
  NProgress.start()
  
  // 获取token
  const hasToken = getToken()
  
  if (hasToken) {
    if (to.path === '/login') {
      // 已登录，跳转到首页
      next({ path: '/' })
      NProgress.done()
    } else {
      // 获取用户和权限仓库
      const userStore = useUserStore()
      const permissionStore = usePermissionStore()
      
      // 检查用户信息是否已获取
      const hasUserInfo = userStore.name
      
      if (hasUserInfo) {
        next()
      } else {
        try {
          // 获取用户信息
          await userStore.getUserInfo()
          
          // 生成路由
          const accessRoutes = await permissionStore.generateRoutes()
          
          // 动态添加路由
          accessRoutes.forEach(route => {
            router.addRoute(route)
          })
          
          // 确保addRoutes已完成
          next({ ...to, replace: true })
        } catch (error) {
          // 出错则重置登录状态
          await userStore.resetToken()
          console.error('路由错误', error)
          next(`/login?redirect=${to.path}`)
          NProgress.done()
        }
      }
    }
  } else {
    // 未登录
    if (whiteList.includes(to.path)) {
      // 白名单路由，直接访问
      next()
    } else {
      // 非白名单路由，重定向到登录页
      next(`/login?redirect=${to.path}`)
      NProgress.done()
    }
  }
})

// 全局后置守卫
router.afterEach(() => {
  // 结束进度条
  NProgress.done()
})
```


### 4.4 优缺点分析

**优点：**
1. **灵活性强**：菜单结构可以在后端动态调整，前端无需重新发布
2. **集中管理**：权限完全由后端控制，前后端权限保持一致
3. **业务分离**：前端专注于UI渲染，无需关心权限逻辑

**缺点：**
1. **性能开销**：每次登录需要额外请求菜单数据，增加首次加载时间
2. **调试复杂**：路由动态生成，调试时难以追踪路由问题
3. **依赖性强**：强依赖后端接口，接口异常会导致前端无法正常初始化

## 5. 方案二：静态路由+权限过滤方案

> [16-权限控制](16-权限控制.md) 其实也是方案二，只不过只有静态路由，没有权限过滤。
### 5.1 实现原理

静态路由+权限过滤方案的核心思想是：**路由配置预先定义在前端**，根据后端返回的权限标识筛选可访问路由。

流程：
1. 前端预先定义所有路由配置，包括路由路径、组件和所需权限
2. 用户登录后，前端向后端请求获取用户权限标识
3. 前端根据用户权限过滤路由配置
4. 动态添加有权限访问的路由到Vue Router

### 5.2 实现思路

1. 将路由分为两类：
   - 常量路由（constantRoutes）：所有用户都可访问的路由，如登录页、404页
   - 异步路由（asyncRoutes）：需要根据权限过滤的路由
2. 在路由配置中添加meta.permission字段，指定访问路由所需的权限
3. 用户登录后获取权限列表
4. 根据权限列表过滤异步路由
5. 动态添加过滤后的路由

### 5.3 伪代码示例

```javascript
// 路由定义伪代码
// 常量路由 - 所有用户可访问
const constantRoutes = [
  { path: '/login', component: Login },
  { path: '/404', component: NotFound }
]

// 异步路由 - 需要权限过滤
const asyncRoutes = [
  {
    path: '/system',
    component: Layout,
    meta: { permission: 'system' },
    children: [
      {
        path: 'user',
        component: User,
        meta: { permission: 'system:user' }
      }
    ]
  }
]

// 根据权限过滤路由伪代码
function filterRoutes(routes, permissions) {
  return routes.filter(route => {
    // 无权限要求或有对应权限
    if (!route.meta?.permission || permissions.includes(route.meta.permission)) {
      // 递归处理子路由
      if (route.children) {
        route.children = filterRoutes(route.children, permissions)
      }
      return true
    }
    return false
  })
}

// 路由守卫伪代码
router.beforeEach(async (to, from, next) => {
  if (hasToken) {
    if (isRouteGenerated) {
      next()
    } else {
      // 获取用户权限
      const permissions = await getUserPermissions()
      
      // 过滤路由
      const accessRoutes = filterRoutes(asyncRoutes, permissions)
      
      // 动态添加路由
      addRoutesToRouter(accessRoutes)
      
      next({ ...to, replace: true })
    }
  } else {
    // 处理未登录情况
  }
})
```

### 5.4 优缺点分析

**优点：**
1. **性能优化**：无需在运行时转换路由结构，减少计算开销
2. **可预测性**：路由结构在代码中明确定义，便于追踪和调试
3. **前端可控**：前端可以独立维护路由配置，减少对后端的依赖

**缺点：**
1. **灵活性差**：菜单结构调整需要修改前端代码并重新发布
2. **代码冗余**：所有可能的路由都需要在前端预先定义
3. **同步问题**：前后端权限配置需要保持同步，容易出现不一致

## 6. 按钮权限控制实现

除了路由权限，按钮级权限控制也是前端权限系统的重要组成部分。以下是三种常用的按钮权限控制方式：

### 6.1 自定义指令方式

```javascript:src/directives/permission.js
import { usePermissionStore } from '@/stores/permission'

export default {
  mounted(el, binding) {
    const { value } = binding
    
    // 获取权限列表
    const permissionStore = usePermissionStore()
    
    // 无权限值或空值处理
    if (!value) {
      return
    }
    
    // 权限检查
    const hasPermission = permissionStore.hasPermission(value)
    
    // 无权限则移除元素
    if (!hasPermission) {
      el.parentNode && el.parentNode.removeChild(el)
    }
  }
}
```

**注册指令：**

```javascript:src/main.js
import { createApp } from 'vue'
import App from './App.vue'
import router from './router'
import permission from './directives/permission'
import pinia from './stores'

const app = createApp(App)

// 注册自定义指令
app.directive('permission', permission)
// 或使用v-auth别名
app.directive('auth', permission)

app.use(pinia)
app.use(router)
app.mount('#app')
```

**使用方式：**

```vue
<template>
  <!-- 单个权限控制 -->
  <el-button v-permission="'user:add'" type="primary">添加用户</el-button>
  
  <!-- 多个权限控制（满足任一权限即可） -->
  <el-button v-permission="['user:edit', 'user:update']" type="warning">编辑用户</el-button>
</template>
```

### 6.2 组件封装方式

```vue:src/components/Permission/index.vue
<template>
  <div v-if="hasPermission">
    <slot></slot>
  </div>
</template>

<script setup>
import { computed } from 'vue'
import { usePermissionStore } from '@/stores/permission'

const props = defineProps({
  permission: {
    type: [String, Array],
    required: true
  }
})

const permissionStore = usePermissionStore()

// 计算是否有权限
const hasPermission = computed(() => {
  return permissionStore.hasPermission(props.permission)
})
</script>
```

**使用方式：**

```vue
<template>
  <Permission :permission="'user:add'">
    <el-button type="primary">添加用户</el-button>
  </Permission>
  
  <Permission :permission="['user:edit', 'user:update']">
    <el-button type="warning">编辑用户</el-button>
  </Permission>
</template>

<script setup>
import Permission from '@/components/Permission/index.vue'
</script>
```

### 6.3 工具函数方式

```javascript:src/utils/permission.js
import { usePermissionStore } from '@/stores/permission'

/**
 * 检查是否有权限
 * @param {string|string[]} permission 权限标识
 * @returns {boolean} 是否有权限
 */
export function hasPermission(permission) {
  const permissionStore = usePermissionStore()
  return permissionStore.hasPermission(permission)
}
```

**使用方式：**

```vue
<template>
  <el-button v-if="hasAddPermission" type="primary">添加用户</el-button>
  <el-button v-if="hasEditPermission" type="warning">编辑用户</el-button>
</template>

<script setup>
import { computed } from 'vue'
import { hasPermission } from '@/utils/permission'

// 计算属性方式
const hasAddPermission = computed(() => hasPermission('user:add'))
const hasEditPermission = computed(() => hasPermission(['user:edit', 'user:update']))

// 方法调用方式
function handleOperation() {
  if (hasPermission('user:delete')) {
    // 有权限，执行删除操作
  } else {
    // 无权限，提示用户
  }
}
</script>
```

## 7. 完整权限流程

前端权限控制的完整流程如下：

1. **用户登录**
   - 用户输入用户名和密码
   - 前端发送登录请求到后端
   - 后端验证成功后返回Token
   - 前端保存Token到Cookie或LocalStorage

2. **获取用户信息**
   - 前端携带Token请求用户信息
   - 后端返回用户基本信息（姓名、头像、角色等）

3. **获取权限数据**
   - 前端请求获取菜单和权限数据
   - 后端根据用户角色返回可访问的菜单和权限标识

4. **路由权限控制**
   - 方案一：将菜单数据转换为路由配置，动态添加
   - 方案二：根据权限标识过滤预定义的路由配置，动态添加有权限的路由

5. **渲染菜单**
   - 使用过滤后的路由或菜单数据渲染导航菜单

6. **按钮权限控制**
   - 使用从菜单中提取的权限标识控制按钮等UI元素的显示
   - 通过自定义指令、权限组件或工具函数实现

## 8. 方案选型建议

**方案一（动态路由方案）适合：**
- 菜单结构需要频繁调整的系统
- 权限管理完全由后端控制的项目
- 前后端分离程度较低的系统
- 对首次加载性能要求不高的系统

**方案二（静态路由+权限过滤）适合：**
- 菜单结构相对固定的系统
- 前端需要更多自主权的项目
- 对首次加载性能要求较高的系统
- 需要前端独立开发和测试的场景

## 9. 最佳实践与注意事项

1. **安全性考虑**
   - 前端权限控制不能代替后端权限校验
   - 所有关键操作都必须在后端进行权限验证
   - 前端权限主要是为了优化用户体验

2. **性能优化**
   - 缓存权限数据，避免频繁请求
   - 使用懒加载减少首次加载时间
   - 路由组件使用keep-alive减少重复渲染

3. **用户体验**
   - 无权限时提供友好的提示
   - 路由切换时显示加载进度
   - 考虑添加权限申请功能

4. **代码组织**
   - 权限逻辑集中管理，避免分散在各个组件
   - 使用Pinia/Vuex统一管理权限状态
   - 权限配置与业务逻辑分离

5. **兼容性与扩展性**
   - 考虑多角色切换的场景
   - 预留自定义权限的扩展接口
   - 进行充分的边界情况测试

6. **调试与错误处理**
   - 添加详细的日志记录
   - 完善的错误处理机制
   - 提供权限问题的排查工具

通过本文档提供的方案和最佳实践，您可以实现一套完整的前端权限控制系统，满足企业级后台管理系统的权限管理需求。根据项目实际情况选择适合的方案，并结合实际需求进行适当调整。
